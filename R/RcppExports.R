# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

mappoly_chisq_test <- function(input_data) {
    .Call('_mappoly2_mappoly_chisq_test', PACKAGE = 'mappoly2', input_data)
}

filter_non_conforming_classes <- function(input_data) {
    .Call('_mappoly2_filter_non_conforming_classes', PACKAGE = 'mappoly2', input_data)
}

find_valid_permutations <- function(H, d, x) {
    .Call('_mappoly2_find_valid_permutations', PACKAGE = 'mappoly2', H, d, x)
}

filter_matrices <- function(mat_list) {
    .Call('_mappoly2_filter_matrices', PACKAGE = 'mappoly2', mat_list)
}

calc_genoprob_biallelic <- function(PH, G, pedigree, rf, err) {
    .Call('_mappoly2_calc_genoprob_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err)
}

calc_genoprob_biallelic_single <- function(PH, G, rf, err) {
    .Call('_mappoly2_calc_genoprob_biallelic_single', PACKAGE = 'mappoly2', PH, G, rf, err)
}

est_hmm_map_biallelic <- function(PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

est_hmm_map_biallelic_single <- function(PH, G, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic_single', PACKAGE = 'mappoly2', PH, G, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

twopt_phasing_cpp <- function(mrk_id, ploidy, dose_vec, S, max_conf_number, verbose) {
    .Call('_mappoly2_twopt_phasing_cpp', PACKAGE = 'mappoly2', mrk_id, ploidy, dose_vec, S, max_conf_number, verbose)
}

phasing_one <- function(mrk_id, dose_vec, S, InitPh, verbose) {
    .Call('_mappoly2_phasing_one', PACKAGE = 'mappoly2', mrk_id, dose_vec, S, InitPh, verbose)
}

#' Mendelian segregation
#'
#' Computes the Mendelian segregation frequencies given the ploidy level
#' of two parents and the dosage of the locus in both parents. It does
#' not consider double reduction.
#'
#' @name segreg_poly
#'
#' @param ploidy.p1 ploidy level of parent 1
#'
#' @param ploidy.p2 ploidy level of parent 1
#'
#' @param d.p1 the dosage in parent 1
#'
#' @param d.p2 the dosage in parent 2
#'
#' @return a vector containing the expected segregation frequency for
#'         genotypic classes.
#'
#' @examples
#' seg1 <- segreg_poly(ploidy_p1 = 6, ploidy_p2 = 6, d_p1 = 3, d_p2 = 3)
#' barplot(seg1)
#' seg2 <- segreg_poly(ploidy_p1 = 2, ploidy_p2 = 4, d_p1 = 2, d_p2 = 3)
#' barplot(seg2)
#'
#' @author Marcelo Mollinari, \email{mmollin@ncsu.edu}
#'
#' @export segreg_poly
#' @importFrom Rcpp evalCpp
NULL

segreg_poly <- function(ploidy_p1, ploidy_p2, d_p1, d_p2) {
    .Call('_mappoly2_segreg_poly', PACKAGE = 'mappoly2', ploidy_p1, ploidy_p2, d_p1, d_p2)
}

est_hmm_map_biallelic_log_implementation <- function(PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic_log_implementation', PACKAGE = 'mappoly2', PH, G, pedigree, rf, err, verbose, detailed_verbose, tol, ret_H0)
}

homologprob_to_hmmstates <- function(h, ploidy1, ploidy2) {
    .Call('_mappoly2_homologprob_to_hmmstates', PACKAGE = 'mappoly2', h, ploidy1, ploidy2)
}

vs_biallelic <- function(PH, G, pedigree) {
    .Call('_mappoly2_vs_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree)
}

vs_biallelic_error <- function(PH, G, pedigree, err, logatithm) {
    .Call('_mappoly2_vs_biallelic_error', PACKAGE = 'mappoly2', PH, G, pedigree, err, logatithm)
}

