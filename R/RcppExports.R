# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

mappoly_chisq_test <- function(input_data) {
    .Call('_mappoly2_mappoly_chisq_test', PACKAGE = 'mappoly2', input_data)
}

filter_non_conforming_classes <- function(input_data) {
    .Call('_mappoly2_filter_non_conforming_classes', PACKAGE = 'mappoly2', input_data)
}

est_hmm_map_biallelic <- function(PH, G, pedigree, rf, verbose, tol, ret_H0) {
    .Call('_mappoly2_est_hmm_map_biallelic', PACKAGE = 'mappoly2', PH, G, pedigree, rf, verbose, tol, ret_H0)
}

pairwise_rf_estimation_disc_rcpp <- function(mrk_pairs_R, m_R, geno_R, d_p1_R, d_p2_R, count_vector_R, count_matrix_phases_R, count_matrix_rownames_R, count_matrix_number_R, count_matrix_pos_R, count_matrix_length_R, tol_R, threads_R) {
    .Call('_mappoly2_pairwise_rf_estimation_disc_rcpp', PACKAGE = 'mappoly2', mrk_pairs_R, m_R, geno_R, d_p1_R, d_p2_R, count_vector_R, count_matrix_phases_R, count_matrix_rownames_R, count_matrix_number_R, count_matrix_pos_R, count_matrix_length_R, tol_R, threads_R)
}

#' Mendelian segregation
#'
#' Computes the Mendelian segregation frequencies given the ploidy level
#' of two parents and the dosage of the locus in both parents. It does
#' not consider double reduction.
#'
#' @name segreg_poly
#'
#' @param ploidy.p1 ploidy level of parent 1
#'
#' @param ploidy.p2 ploidy level of parent 1
#'
#' @param d.p1 the dosage in parent 1
#'
#' @param d.p2 the dosage in parent 2
#'
#' @return a vector containing the expected segregation frequency for
#'         genotypic classes.
#'
#' @examples
#' seg1 <- segreg_poly(ploidy_p1 = 6, ploidy_p2 = 6, d_p1 = 3, d_p2 = 3)
#' barplot(seg1)
#' seg2 <- segreg_poly(ploidy_p1 = 2, ploidy_p2 = 4, d_p1 = 2, d_p2 = 3)
#' barplot(seg2)
#'
#' @author Marcelo Mollinari, \email{mmollin@ncsu.edu}
#'
#' @export segreg_poly
#' @importFrom Rcpp evalCpp
NULL

segreg_poly <- function(ploidy_p1, ploidy_p2, d_p1, d_p2) {
    .Call('_mappoly2_segreg_poly', PACKAGE = 'mappoly2', ploidy_p1, ploidy_p2, d_p1, d_p2)
}

twopt_phasing_cpp <- function(mrk_id, ploidy, dose_vec, S) {
    .Call('_mappoly2_twopt_phasing_cpp', PACKAGE = 'mappoly2', mrk_id, ploidy, dose_vec, S)
}

